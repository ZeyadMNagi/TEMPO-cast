const express = require("express");
const axios = require("axios");
const fs = require("node:fs/promises");
const fsSync = require("node:fs");
const path = require("node:path");
const NodeCache = require("node-cache");
const serverless = require("serverless-http");
require("dotenv").config();
const app = express();

app.set("trust proxy", 1);

const compression = require("compression");
app.use(compression());

const cache = new NodeCache({ stdTTL: 300, checkperiod: 60 });

app.use(
  express.static("public", {
    maxAge: "1h",
    etag: true,
  })
);
app.use(express.json());
const router = express.Router();
const PORT = process.env.PORT || 3000;

const rateLimit = require("express-rate-limit");
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: "Too many requests from this IP, please try again later.",
});

if (process.env.NODE_ENV === "production") {
  router.use(limiter);
}

// --- GEMS Image Service Integration ---
const GEMS_API_KEY =
  process.env.GEMS_API_KEY || "api-c455c74c0a854d36868021840d32e01f";
const GEMS_DATA_DIR = path.join(require("os").tmpdir(), "gems_data");
const GEMS_IMAGE_BOUNDS = [
  [-34, 48],
  [58, 168],
];

// Cache GEMS images in memory for serverless environment
const gemsImageCache = new NodeCache({ stdTTL: 3600, checkperiod: 120 }); // 1 hour cache

const GEMS_LAYERS = {
  o3: {
    baseUrl: "https://nesc.nier.go.kr:38032/api/GK2/L2/O3T/FOR/image",
  },
  hcho: {
    baseUrl: "https://nesc.nier.go.kr:38032/api/GK2/L2/HCHO/FOR/image",
  },
  no2: {
    baseUrl: "https://nesc.nier.go.kr:38032/api/GK2/L2/NO2_Trop/FOR/image",
  },
};

async function fetchLatestGemsTimestamp(baseUrl) {
  const now = new Date();
  const end = now.toISOString().slice(0, 16).replace(/[-T:]/g, "");
  now.setHours(now.getHours() - 24);
  const start = now.toISOString().slice(0, 16).replace(/[-T:]/g, "");

  const url = `${baseUrl}/getFileDateList.do?sDate=${start}&eDate=${end}&format=json&key=${GEMS_API_KEY}`;
  
  console.log(`[GEMS] Fetching timestamp from: ${url}`);
  
  try {
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'application/json',
      }
    });
    
    console.log(`[GEMS] Timestamp API response status: ${response.status}`);
    
    if (!response.ok) {
      const text = await response.text();
      console.error(`[GEMS] Timestamp API error response:`, text.substring(0, 200));
      throw new Error(`GEMS API returned status: ${response.status}`);
    }
    
    const data = await response.json();

    if (!data || !Array.isArray(data.list) || data.list.length === 0) {
      console.error(`[GEMS] Invalid data structure:`, JSON.stringify(data).substring(0, 200));
      throw new Error(`GEMS API returned no data.`);
    }

    const timestamps = data.list.map((item) => item.item);
    console.log(`[GEMS] Found ${timestamps.length} timestamps, latest: ${timestamps[timestamps.length - 1]}`);
    
    return timestamps.sort().pop();
  } catch (error) {
    console.error(`[GEMS] fetchLatestGemsTimestamp failed:`, error);
    throw error;
  }
}

async function fetchGemsImage(layerName) {
  const layer = GEMS_LAYERS[layerName];
  if (!layer) {
    throw new Error(`Unknown GEMS layer: ${layerName}`);
  }

  // Check cache first
  const cachedImage = gemsImageCache.get(layerName);
  if (cachedImage) {
    console.log(`[GEMS-${layerName.toUpperCase()}] Using cached image`);
    return cachedImage;
  }

  console.log(`[GEMS-${layerName.toUpperCase()}] Fetching fresh image...`);

  try {
    // Get latest timestamp
    const timestamp = await fetchLatestGemsTimestamp(layer.baseUrl);
    console.log(`[GEMS-${layerName.toUpperCase()}] Latest timestamp: ${timestamp}`);

    // Download image with timeout
    const imageUrl = `${layer.baseUrl}/getFileItem.do?date=${timestamp}&key=${GEMS_API_KEY}`;
    console.log(`[GEMS-${layerName.toUpperCase()}] Fetching from: ${imageUrl}`);
    
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 25000); // 25 second timeout
    
    const response = await fetch(imageUrl, { signal: controller.signal });
    clearTimeout(timeout);
    
    console.log(`[GEMS-${layerName.toUpperCase()}] Response status: ${response.status}`);
    console.log(`[GEMS-${layerName.toUpperCase()}] Content-Type: ${response.headers.get('content-type')}`);
    
    if (!response.ok) {
      throw new Error(`Download failed with status ${response.status}`);
    }

    const imageBuffer = Buffer.from(await response.arrayBuffer());
    console.log(`[GEMS-${layerName.toUpperCase()}] Image downloaded (${imageBuffer.length} bytes, ${(imageBuffer.length / 1024 / 1024).toFixed(2)} MB)`);

    // Verify it's actually an image
    if (imageBuffer.length < 100) {
      throw new Error(`Image too small (${imageBuffer.length} bytes) - likely not a valid image`);
    }

    // Check PNG magic bytes
    const isPNG = imageBuffer[0] === 0x89 && imageBuffer[1] === 0x50 && imageBuffer[2] === 0x4E && imageBuffer[3] === 0x47;
    if (!isPNG) {
      console.warn(`[GEMS-${layerName.toUpperCase()}] Warning: Does not appear to be a PNG file`);
      console.log(`[GEMS-${layerName.toUpperCase()}] First bytes:`, imageBuffer.slice(0, 10));
    }

    // Cache the image buffer in memory
    gemsImageCache.set(layerName, imageBuffer);
    console.log(`[GEMS-${layerName.toUpperCase()}] Image cached successfully`);

    return imageBuffer;
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error(`[GEMS-${layerName.toUpperCase()}] Fetch timeout after 25s`);
      throw new Error('GEMS API request timed out');
    }
    console.error(`[GEMS-${layerName.toUpperCase()}] Fetch failed:`, error.message);
    throw error;
  }
}

// --- End GEMS Integration ---

// Cache middleware
const getCacheKey = (lat, lon, endpoint) => `${endpoint}_${lat}_${lon}`;

const cacheMiddleware = (endpoint) => {
  return (req, res, next) => {
    const { lat, lon } = req.query;
    if (!lat || !lon) return next();

    const cacheKey = getCacheKey(lat, lon, endpoint);
    const cachedData = cache.get(cacheKey);

    if (cachedData) {
      console.log(`Cache hit for ${endpoint}: ${cacheKey}`);
      return res.json(cachedData);
    }

    // Store original json method
    const originalJson = res.json;

    // Override json method to cache the response
    res.json = function (data) {
      cache.set(cacheKey, data);
      console.log(`Cached data for ${endpoint}: ${cacheKey}`);
      originalJson.call(this, data);
    };

    next();
  };
};

// Optimized API endpoints with caching and parallel requests
router.get("/data", cacheMiddleware("data"), async (req, res) => {
  const { lat, lon } = req.query;

  if (!lat || !lon) {
    return res.status(400).json({ error: "Missing lat/lon" });
  }

  try {
    // Use Promise.allSettled for better error handling
    const [currentPollutionResult, weatherResult, airQualityResult] =
      await Promise.allSettled([
        axios.get(`http://api.openweathermap.org/data/2.5/air_pollution`, {
          params: { lat, lon, appid: process.env.OPENWEATHER_API_KEY },
          timeout: 5000,
        }),
        axios.get(`http://api.openweathermap.org/data/2.5/weather`, {
          params: {
            lat,
            lon,
            appid: process.env.OPENWEATHER_API_KEY,
            units: "metric",
          },
          timeout: 5000,
        }),
        axios
          .get(`https://api.openaq.org/v3/locations`, {
            headers: { "X-API-Key": process.env.OPENAQ_API_KEY },
            params: { coordinates: `${lat},${lon}`, radius: 25000, limit: 1 },
            timeout: 8000,
          })
          .catch(() => null), // Non-blocking failure
      ]);

    // Handle results
    if (
      currentPollutionResult.status === "rejected" ||
      weatherResult.status === "rejected"
    ) {
      throw new Error("Failed to fetch essential data");
    }

    const combinedData = {
      ...currentPollutionResult.value.data,
      weather: weatherResult.value.data,
    };

    const airQualityData =
      airQualityResult.status === "fulfilled" && airQualityResult.value
        ? airQualityResult.value.data.results?.[0] || null
        : null;

    res.json({
      location: weatherResult.value.data.name,
      weather: combinedData,
      airQuality: airQualityData,
    });
  } catch (err) {
    console.error("API Error:", err.message);
    res.status(500).json({ error: "Failed to fetch current data" });
  }
});

// Optimized forecast endpoint with caching
router.get("/forecast", cacheMiddleware("forecast"), async (req, res) => {
  const { lat, lon } = req.query;

  if (!lat || !lon) {
    return res.status(400).json({ error: "Missing lat/lon" });
  }

  try {
    const forecastResponse = await axios.get(
      `http://api.openweathermap.org/data/2.5/air_pollution/forecast`,
      {
        params: { lat, lon, appid: process.env.OPENWEATHER_API_KEY },
        timeout: 8000,
      }
    );

    res.json({
      coord: forecastResponse.data.coord,
      forecast: forecastResponse.data.list,
      totalHours: forecastResponse.data.list.length,
    });
  } catch (err) {
    console.error("Forecast API Error:", err.message);
    res.status(500).json({ error: "Failed to fetch forecast data" });
  }
});

// Optimized historical endpoint with caching
router.get("/historical", cacheMiddleware("historical"), async (req, res) => {
  const { lat, lon, days } = req.query;

  if (!lat || !lon) {
    return res.status(400).json({ error: "Missing lat/lon" });
  }

  try {
    const daysBack = Math.min(parseInt(days) || 7, 30); // Limit to 30 days max
    const endTime = Math.floor(Date.now() / 1000);
    const startTime = endTime - daysBack * 24 * 60 * 60;

    const historicalResponse = await axios.get(
      `http://api.openweathermap.org/data/2.5/air_pollution/history`,
      {
        params: {
          lat,
          lon,
          start: startTime,
          end: endTime,
          appid: process.env.OPENWEATHER_API_KEY,
        },
        timeout: 10000,
      }
    );

    res.json({
      coord: historicalResponse.data.coord,
      historical: historicalResponse.data.list,
      period: { start: startTime, end: endTime, days: daysBack },
    });
  } catch (err) {
    console.error("Historical API Error:", err.message);
    res.status(500).json({ error: "Failed to fetch historical data" });
  }
});

// Optimized complete endpoint with intelligent caching and parallel processing
router.get("/complete", cacheMiddleware("complete"), async (req, res) => {
  const { lat, lon, days } = req.query;

  if (!lat || !lon) {
    return res.status(400).json({ error: "Missing lat/lon" });
  }

  try {
    const daysBack = Math.min(parseInt(days) || 7, 30);
    const endTime = Math.floor(Date.now() / 1000);
    const startTime = endTime - daysBack * 24 * 60 * 60;

    // Use Promise.allSettled for better error handling
    const [currentRes, forecastRes, weatherRes, historicalRes, airQualityRes] =
      await Promise.allSettled([
        axios.get(`http://api.openweathermap.org/data/2.5/air_pollution`, {
          params: { lat, lon, appid: process.env.OPENWEATHER_API_KEY },
          timeout: 5000,
        }),
        axios.get(
          `http://api.openweathermap.org/data/2.5/air_pollution/forecast`,
          {
            params: { lat, lon, appid: process.env.OPENWEATHER_API_KEY },
            timeout: 8000,
          }
        ),
        axios.get(`http://api.openweathermap.org/data/2.5/weather`, {
          params: {
            lat,
            lon,
            appid: process.env.OPENWEATHER_API_KEY,
            units: "metric",
          },
          timeout: 5000,
        }),
        axios.get(
          `http://api.openweathermap.org/data/2.5/air_pollution/history`,
          {
            params: {
              lat,
              lon,
              start: startTime,
              end: endTime,
              appid: process.env.OPENWEATHER_API_KEY,
            },
            timeout: 10000,
          }
        ),
        axios
          .get(`https://api.openaq.org/v3/locations`, {
            headers: { "X-API-Key": process.env.OPENAQ_API_KEY },
            params: { coordinates: `${lat},${lon}`, radius: 25000, limit: 1 },
            timeout: 8000,
          })
          .catch(() => null), // Non-blocking failure
      ]);

    // Check essential requests
    const essentialFailed = [currentRes, weatherRes].some(
      (result) => result.status === "rejected"
    );
    if (essentialFailed) {
      throw new Error("Failed to fetch essential data");
    }

    // Get air quality data (non-blocking)
    let airQualityData = null;
    if (airQualityRes.status === "fulfilled" && airQualityRes.value) {
      airQualityData = airQualityRes.value.data.results?.[0] || null;
    }

    // Combine current pollution with weather
    const combinedCurrent = {
      ...currentRes.value.data,
      weather: weatherRes.value.data,
    };

    res.json({
      location: weatherRes.value.data.name,
      current: combinedCurrent,
      forecast:
        forecastRes.status === "fulfilled"
          ? {
              coord: forecastRes.value.data.coord,
              list: forecastRes.value.data.list,
            }
          : null,
      historical:
        historicalRes.status === "fulfilled"
          ? {
              coord: historicalRes.value.data.coord,
              list: historicalRes.value.data.list,
              period: { start: startTime, end: endTime, days: daysBack },
            }
          : null,
      airQuality: airQualityData,
      timestamp: Date.now(),
    });
  } catch (err) {
    console.error("Complete API Error:", err.message);
    res.status(500).json({ error: "Failed to fetch complete data" });
  }
});

// Health check endpoint
router.get("/health", (req, res) => {
  res.json({
    status: "ok",
    timestamp: new Date().toISOString(),
    cache: {
      keys: cache.keys().length,
      stats: cache.getStats(),
    },
    gems: {
      cachedLayers: gemsImageCache.keys(),
      cacheStats: gemsImageCache.getStats(),
    },
  });
});

// GEMS image endpoint - fetch on demand
router.get("/gems/:layer/image", async (req, res) => {
  const layerName = req.params.layer;

  if (!GEMS_LAYERS[layerName]) {
    return res.status(404).json({ error: "Unknown GEMS layer" });
  }

  try {
    console.log(`[GEMS-${layerName}] Image request received`);
    const imageBuffer = await fetchGemsImage(layerName);
    console.log(`[GEMS-${layerName}] Sending image (${imageBuffer.length} bytes)`);
    
    res.set("Content-Type", "image/png");
    res.set("Cache-Control", "public, max-age=3600"); // Cache for 1 hour
    res.set("Content-Length", imageBuffer.length);
    res.send(imageBuffer);
  } catch (error) {
    console.error(`[GEMS-${layerName}] Error:`, error);
    res.status(503).json({
      error: "Failed to fetch GEMS image",
      message: error.message,
      layer: layerName,
      stack: process.env.NODE_ENV === "development" ? error.stack : undefined,
    });
  }
});

// Debug endpoint to test GEMS API connectivity
router.get("/gems/:layer/debug", async (req, res) => {
  const layerName = req.params.layer;
  const layer = GEMS_LAYERS[layerName];

  if (!layer) {
    return res.status(404).json({ error: "Unknown GEMS layer" });
  }

  const debugInfo = {
    layer: layerName,
    baseUrl: layer.baseUrl,
    apiKey: GEMS_API_KEY ? `${GEMS_API_KEY.substring(0, 10)}...` : "NOT SET",
    cached: gemsImageCache.has(layerName),
    cacheStats: gemsImageCache.getStats(),
    steps: [],
  };

  try {
    // Step 1: Get timestamp
    debugInfo.steps.push({ step: 1, action: "Fetching timestamp list..." });
    const now = new Date();
    const end = now.toISOString().slice(0, 16).replace(/[-T:]/g, "");
    now.setHours(now.getHours() - 24);
    const start = now.toISOString().slice(0, 16).replace(/[-T:]/g, "");

    const listUrl = `${layer.baseUrl}/getFileDateList.do?sDate=${start}&eDate=${end}&format=json&key=${GEMS_API_KEY}`;
    debugInfo.listUrl = listUrl;

    const listResponse = await fetch(listUrl);
    debugInfo.steps.push({
      step: 1,
      status: listResponse.status,
      ok: listResponse.ok,
    });

    if (!listResponse.ok) {
      throw new Error(`Timestamp API returned ${listResponse.status}`);
    }

    const listData = await listResponse.json();
    debugInfo.steps.push({
      step: 1,
      result: "success",
      dataReceived: listData.list?.length || 0,
    });

    if (!listData.list || listData.list.length === 0) {
      throw new Error("No timestamps available");
    }

    const timestamp = listData.list.map((item) => item.item).sort().pop();
    debugInfo.timestamp = timestamp;
    debugInfo.steps.push({ step: 2, action: "Latest timestamp", value: timestamp });

    // Step 2: Try to fetch image
    const imageUrl = `${layer.baseUrl}/getFileItem.do?date=${timestamp}&key=${GEMS_API_KEY}`;
    debugInfo.imageUrl = imageUrl;
    debugInfo.steps.push({ step: 3, action: "Fetching image..." });

    const imageResponse = await fetch(imageUrl);
    debugInfo.steps.push({
      step: 3,
      status: imageResponse.status,
      ok: imageResponse.ok,
      contentType: imageResponse.headers.get("content-type"),
      contentLength: imageResponse.headers.get("content-length"),
    });

    if (imageResponse.ok) {
      const imageBuffer = Buffer.from(await imageResponse.arrayBuffer());
      debugInfo.steps.push({
        step: 3,
        result: "success",
        imageSize: imageBuffer.length,
        imageSizeMB: (imageBuffer.length / 1024 / 1024).toFixed(2),
      });
      debugInfo.success = true;
    } else {
      debugInfo.success = false;
      debugInfo.error = `Image fetch returned ${imageResponse.status}`;
    }

    res.json(debugInfo);
  } catch (error) {
    debugInfo.success = false;
    debugInfo.error = error.message;
    debugInfo.errorStack = process.env.NODE_ENV === "development" ? error.stack : undefined;
    res.status(500).json(debugInfo);
  }
});

// GEMS bounds endpoint - always returns bounds immediately
router.get("/gems/:layer/bounds", async (req, res) => {
  const layerName = req.params.layer;

  if (!GEMS_LAYERS[layerName]) {
    return res.status(404).json({ error: "Unknown GEMS layer" });
  }

  // Always return bounds immediately - no "ready" check needed
  res.json({
    bounds: GEMS_IMAGE_BOUNDS,
    layer: layerName,
    cached: gemsImageCache.has(layerName),
  });
});

router.get("/cache-stats", (req, res) => {
  res.json({
    weather: cache.getStats(),
    gems: gemsImageCache.getStats(),
  });
});

app.use("/api/", router);

app.use((err, req, res, _next) => {
  console.error(err.stack);
  res.status(500).json({ error: "Something went wrong!" });
});

module.exports.handler = serverless(app);

// This part is for local development only
if (process.env.NODE_ENV !== "production") {
  app.listen(PORT, () => console.log(`Local server running on port ${PORT}`));
}